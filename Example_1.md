# Sleep-Wakeup Process Scheduling #
## Description ##
In this model, two client processes compete for some resource, and one server takes responsibility for waking up asleep processes when the
resource is available.

## Property to Check ##
The resource is accessed by at most one process all the time

## SPIN Model ##
```
#define N 2
mtype = { Wakeme, Running };

bit     lk, sleep_q;
bit     r_want;
int     r_lock;
mtype	State =	Running;

ltl  { [] (r_lock == 0 || r_lock == 1) }

active[N] proctype client()
{
sleep:					            
	atomic { (lk == 0) -> lk = 1 };	
	do				                
	::  (r_lock == 1) ->		     
		r_want = 1;
        atomic {
		    (sleep_q == 0) -> sleep_q = 1;
		}
		State = Wakeme;
		lk = 0;			         
        sleep_q = 0;
		(State == Running);
        goto sleep;
	::  else ->		
		break
	od;
progress:
	assert(r_lock == 0);
	r_lock++;			        
	lk = 0;				    
	goto sleep
}

active proctype server()	
{
wakeup:					  
	r_lock = 0;			    
	lk == 0;			    
	if
	::  r_want ->			
		r_want = 0;
		atomic {		      
			(sleep_q == 0) -> sleep_q = 1
		};
		if
		:: (State == Wakeme) ->
			State = Running;
		:: else ->
		fi;
		sleep_q = 0
	::  else ->
	fi;
	goto wakeup
}
```
## NuSMV Model Generated by S2N ##
```
MODULE main
  VAR
    lk : boolean;
    sleep_q : boolean;
    r_want : boolean;
    r_lock : signed word[32];
    State : { Running, Wakeme };
    p1_client : process client(self);
    p2_client : process client(self);
    p_server : process server(self);
  ASSIGN
    init(lk) := FALSE;
    init(sleep_q) := FALSE;
    init(r_want) := FALSE;
    init(r_lock) := swconst(0, 32);
    init(State) := Running;
  TRANS
    !running
  INVARSPEC r_lock = swconst(0, 32) | r_lock = swconst(1, 32)

MODULE client(sup)
  VAR
    pc : 1..18;
  ASSIGN
    init(pc) := 1;
    next(sup.lk) := 
            case
               pc = 2 : TRUE;
               pc = 9 : FALSE;
               pc = 16 : FALSE;
               TRUE   : sup.lk;
            esac;
    next(sup.r_want) := 
            case
               pc = 5 : TRUE;
               TRUE   : sup.r_want;
            esac;
    next(sup.sleep_q) := 
            case
               pc = 7 : TRUE;
               pc = 10 : FALSE;
               TRUE   : sup.sleep_q;
            esac;
    next(sup.State) := 
            case
               pc = 8 : Wakeme;
               TRUE   : sup.State;
            esac;
    next(sup.r_lock) := 
            case
               pc = 15 : sup.r_lock + swconst(1,32);
               TRUE   : sup.r_lock;
            esac;
  TRANS
      ( running & (
               pc = 1 & (!sup.lk) & next(pc) = 2
             | pc = 2 & next(pc) = 3
             | pc = 3 & (sup.r_lock = swconst(1,32)) & next(pc) = 4
             | pc = 3 & !(sup.r_lock = swconst(1,32)) & next(pc) = 13
             | pc = 4 & next(pc) = 5
             | pc = 5 & next(pc) = 6
             | pc = 6 & (!sup.sleep_q) & next(pc) = 7
             | pc = 7 & next(pc) = 8
             | pc = 8 & next(pc) = 9
             | pc = 9 & next(pc) = 10
             | pc = 10 & next(pc) = 11
             | pc = 11 & (sup.State = Running) & next(pc) = 12
             | pc = 12 & next(pc) = 1
             | pc = 13 & next(pc) = 14
             | pc = 14 & next(pc) = 15
             | pc = 15 & next(pc) = 16
             | pc = 16 & next(pc) = 17
             | pc = 17 & next(pc) = 1
             )
      | !running & next(pc) = pc )
    & ( pc = 2
      | pc = 4
      | pc = 7
      | pc = 13
       -> running )
    & ( pc = 1 & !(!sup.lk)
      | pc = 6 & !(!sup.sleep_q)
      | pc = 11 & !(sup.State = Running)
      | pc = 18
       -> !running )


MODULE server(sup)
  VAR
    pc : 1..15;
  ASSIGN
    init(pc) := 1;
    next(sup.r_lock) := 
            case
               pc = 1 : swconst(0,32);
               TRUE   : sup.r_lock;
            esac;
    next(sup.r_want) := 
            case
               pc = 5 : FALSE;
               TRUE   : sup.r_want;
            esac;
    next(sup.sleep_q) := 
            case
               pc = 7 : TRUE;
               pc = 12 : FALSE;
               TRUE   : sup.sleep_q;
            esac;
    next(sup.State) := 
            case
               pc = 10 : Running;
               TRUE   : sup.State;
            esac;
  TRANS
      ( running & (
               pc = 1 & next(pc) = 2
             | pc = 2 & !sup.lk & next(pc) = 3
             | pc = 3 & sup.r_want & next(pc) = 4
             | pc = 3 & !sup.r_want & next(pc) = 13
             | pc = 4 & next(pc) = 5
             | pc = 5 & next(pc) = 6
             | pc = 6 & (!sup.sleep_q) & next(pc) = 7
             | pc = 7 & next(pc) = 8
             | pc = 8 & (sup.State = Wakeme) & next(pc) = 9
             | pc = 8 & !(sup.State = Wakeme) & next(pc) = 11
             | pc = 9 & next(pc) = 10
             | pc = 10 & next(pc) = 12
             | pc = 11 & next(pc) = 12
             | pc = 12 & next(pc) = 14
             | pc = 13 & next(pc) = 14
             | pc = 14 & next(pc) = 1
             )
      | !running & next(pc) = pc )
    & ( pc = 4
      | pc = 7
      | pc = 9
      | pc = 11
      | pc = 13
       -> running )
    & ( pc = 2 & sup.lk
      | pc = 6 & !(!sup.sleep_q)
      | pc = 15
       -> !running )

```
